<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SONY HASH</title>
<script>
  if(location.search.includes('airgap=1') || location.hash === '#airgap') {
    document.write('<meta http-equiv="Content-Security-Policy" content="default-src \'self\'; script-src \'self\' \'unsafe-inline\' blob:; style-src \'self\' \'unsafe-inline\'; worker-src \'self\' blob:; connect-src \'none\'; object-src \'none\'; base-uri \'none\'; frame-ancestors \'none\';">');
    window.__ZESS_MODE__ = true;
  } else {
    document.write('<meta http-equiv="Content-Security-Policy" content="default-src \'self\'; script-src \'self\' \'unsafe-inline\' blob:; style-src \'self\' \'unsafe-inline\'; worker-src \'self\' blob:; img-src \'self\' data:; connect-src \'self\' https://api.ipify.org https://worldtimeapi.org https://ipapi.co https://ipinfo.io https://ip-api.com https://ipwho.is https://www.cloudflare.com; object-src \'none\'; base-uri \'none\'; frame-ancestors \'none\';">');
  }
</script>
<meta name="referrer" content="no-referrer">
<style>
  :root{
    --bg:#0a2a45;
    --fg:#7cff7c;
    --fg-bright:#39ff14;
    --muted:#9fb4c6;
    --alert:#ff4747;
    --drag-bg:rgba(124,255,124,0.08);
    --glow:0 0 1px rgba(124,255,124,.25);
    --toast-bg:rgba(10,42,69,.8);
    --sys-offset:120px;
    --scanline:repeating-linear-gradient(to bottom,rgba(255,255,255,.025),rgba(255,255,255,.025) 1px,transparent 1px,transparent 3px);
    --font-stack:ui-monospace,SFMono-Regular,Menlo,Consolas,"MS Gothic",monospace;
    --sel-bg:rgba(124,255,124,0.3);
    --sel-fg:#ffffff;
    --sb-track:rgba(0,0,0,0.2);
    --sb-thumb:rgba(124,255,124,0.3);
    --sb-thumb-hover:rgba(124,255,124,0.6);
  }
  body[data-theme="cmd"]{
    --bg:#0c0c0c;
    --fg:#cccccc;
    --fg-bright:#ffffff;
    --muted:#888888;
    --drag-bg:rgba(255,255,255,0.08);
    --glow:none;
    --toast-bg:rgba(30,30,30,.8);
    --scanline:none;
    --font-stack:Consolas,"MS Gothic","ＭＳ ゴシック",monospace;
    --sel-bg:#ffffff;
    --sel-fg:#0c0c0c;
    --sb-track:#0c0c0c;
    --sb-thumb:#888888;
    --sb-thumb-hover:#cccccc;
  }
  body[data-theme="ps"]{
    --bg:#012456;
    --fg:#eeedf0;
    --fg-bright:#ffe900;
    --muted:#8b9bb4;
    --drag-bg:rgba(255,233,0,0.08);
    --glow:none;
    --toast-bg:rgba(1,36,86,.8);
    --scanline:none;
    --font-stack:Consolas,"MS Gothic","ＭＳ ゴシック",monospace;
    --sel-bg:#eeedf0;
    --sel-fg:#012456;
    --sb-track:#012456;
    --sb-thumb:rgba(255,255,255,0.3);
    --sb-thumb-hover:rgba(255,255,255,0.6);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--fg);
    font-family:var(--font-stack);
    line-height:1.55; display:flex; flex-direction:column; min-height:100vh;
    background-image:var(--scanline);
    -webkit-font-smoothing:antialiased; image-rendering:pixelated;
  }
  body.airgap {
    background-image:repeating-linear-gradient(to bottom,rgba(255,71,71,.05),rgba(255,71,71,.05) 1px,transparent 1px,transparent 3px);
    border: 1px solid rgba(255,71,71,.3);
  }
  body.airgap .brandline { color: var(--alert); }

  ::-webkit-scrollbar { width: 14px; height: 14px; }
  ::-webkit-scrollbar-track { background: var(--sb-track); }
  ::-webkit-scrollbar-thumb { background: var(--sb-thumb); border: 3px solid var(--bg); border-radius: 0; }
  ::-webkit-scrollbar-thumb:hover { background: var(--sb-thumb-hover); }
  ::-webkit-scrollbar-corner { background: var(--bg); }

  ::selection { background: var(--sel-bg); color: var(--sel-fg); text-shadow: none; }
  ::-moz-selection { background: var(--sel-bg); color: var(--sel-fg); text-shadow: none; }
  textarea::selection { background: var(--sel-bg); color: var(--sel-fg); text-shadow: none; }
  textarea::-moz-selection { background: var(--sel-bg); color: var(--sel-fg); text-shadow: none; }

  header{display:flex;align-items:center;justify-content:space-between;padding:12px clamp(12px,3vw,24px);color:var(--fg)}
  h1{margin:0;font-size:clamp(18px,4.5vw,28px);letter-spacing:.06em}
  .link{background:none;border:none;padding:0;margin-left:12px;color:var(--muted);text-decoration:underline;cursor:pointer;font-size:clamp(12px,3.2vw,14px)}
  .link.warn { color: var(--alert); }
  .container{width:min(1100px,96vw);margin:0 auto;flex:1;display:flex;flex-direction:column;gap:10px;padding:0 0 var(--sys-offset)}
  .input-wrap{position:relative;padding:10px clamp(12px,3vw,18px);transition:background 0.2s}
  .input-wrap.dragover{background:var(--drag-bg);outline:2px dashed var(--fg-bright)}
  textarea{
    width:100%;min-height:28vh;background:transparent;color:var(--fg);
    border:none;outline:none;caret-color:var(--fg-bright);
    font:inherit;font-size:clamp(14px,2.8vw,18px);line-height:1.65;resize:vertical;
    text-shadow:var(--glow);
  }
  .hint{color:var(--muted);font-size:clamp(11px,2.6vw,13px);margin-top:6px}
  .toolbar{display:flex;align-items:center;gap:12px;padding:0 clamp(12px,3vw,18px);flex-wrap:wrap}
  .toolbar .sep{opacity:.5}
  .list{display:grid;grid-template-columns:1fr;gap:6px;padding:0 clamp(12px,3vw,18px)}
  @media (min-width:720px){ .list{grid-template-columns:1fr 1fr} }
  .row{display:flex;gap:10px;align-items:flex-start;padding:2px 0}
  .label{width:90px;flex:0 0 90px;color:var(--muted)}
  .value{flex:1;color:var(--fg-bright);word-break:break-all;user-select:text}
  .value:focus{outline:1px dashed var(--fg-bright); outline-offset:2px}
  .value[data-empty="1"]{opacity:.6}
  .value[data-is-binary="1"]{color:var(--fg);text-decoration:underline;cursor:pointer}
  .toast{
    position:fixed;left:50%;bottom:24px;transform:translateX(-50%);
    background:var(--toast-bg);color:var(--fg-bright);
    padding:6px 10px;border-radius:6px;font-size:12px;pointer-events:none;opacity:0;transition:opacity .15s;
    z-index: 1000;
  }
  .toast.show{opacity:1}
  .sys{
    position:fixed;right:10px;bottom:10px;width:min(56ch,92vw);
    color:var(--muted);font-size:12px;line-height:1.35;white-space:pre-wrap;text-align:right;
    pointer-events:auto; user-select:text;
  }
  .brandline{color:var(--fg-bright);font-weight:600}
  #f-hidden{display:none}
</style>
</head>
<body>
  <header>
    <h1>SONY HASH</h1>
    <div>
      <button id="themeToggle" class="link" aria-label="テーマ切替">テーマ: DEFAULT</button>
      <button id="fs" class="link" aria-label="全画面">全画面</button>
    </div>
  </header>
  <main class="container" role="main">
    <section class="input-wrap" id="drop-zone">
      <textarea id="in" placeholder="ここに入力、またはファイルをドロップして計算します"></textarea>
      <div id="meta" class="hint">文字数 0｜正規化: NFC｜HEX: lower｜区切り: 連結｜ステータス: 待機</div>
      <input type="file" id="f-hidden" />
    </section>
    <div class="toolbar">
      <span class="hint">オプション:</span>
      <button id="norm" class="link" aria-label="正規化の切替">正規化: NFC</button><span class="sep hint">/</span>
      <button id="hexcase" class="link" aria-label="HEX大小の切替">HEX: lower</button>
      <span class="sep hint">/</span>
      <button id="Base64EncToggle" class="link" aria-label="Base64エンコードの切替">Base64 Enc: オフ</button>
      <span class="sep hint">/</span>
      <button id="Base64DecToggle" class="link" aria-label="Base64デコードの切替">Base64 Dec: オフ</button>
      <span class="sep hint">/</span>
      <button id="Base85EncToggle" class="link" aria-label="Base85エンコードの切替">Base85 Enc: オフ</button>
      <span class="sep hint">/</span>
      <button id="Base85DecToggle" class="link" aria-label="Base85デコードの切替">Base85 Dec: オフ</button>
      <span class="sep hint">/</span>
      <label for="grouping" class="hint">区切り:</label>
      <select id="grouping" class="link" style="text-decoration:none">
        <option value="0">連結</option>
        <option value="2">2字</option>
        <option value="4">4字</option>
        <option value="8">8字</option>
        <option value="16">16字</option>
      </select>
      <span class="sep hint">|</span>
      <button id="f-trigger" class="link">ファイル読込</button>
      <span class="sep hint">|</span>
      <span class="hint">テスト:</span>
      <select id="tv" class="link" style="text-decoration:none">
        <option value="empty">空</option>
        <option value="abc">abc</option>
      </select>
      <button id="apply" class="link">適用</button>
      <button id="verify" class="link">検証</button>
      <span class="sep hint">|</span>
      <button id="save" class="link">保存</button>
      <span class="sep hint">|</span>
      <button id="geoToggle" class="link" aria-label="位置情報の照会">位置: オフ</button>
      <span class="sep hint">|</span>
      <button id="zessToggle" class="link" aria-label="ZESS隔離モード">ZESS: オフ</button>
    </div>
    <section class="list mono" aria-live="polite" aria-busy="false">
      <div class="row"><div class="label">MD5</div>      <div id="MD5"     class="value" data-alg="MD5" tabindex="0">入力待ち</div></div>
      <div class="row"><div class="label">SHA-1</div>   <div id="SHA-1"   class="value" data-alg="SHA-1" tabindex="0">入力待ち</div></div>
      <div class="row"><div class="label">SHA-256</div> <div id="SHA-256" class="value" data-alg="SHA-256" tabindex="0">入力待ち</div></div>
      <div class="row"><div class="label">SHA-384</div> <div id="SHA-384" class="value" data-alg="SHA-384" tabindex="0">入力待ち</div></div>
      <div class="row"><div class="label">SHA-512</div> <div id="SHA-512" class="value" data-alg="SHA-512" tabindex="0">入力待ち</div></div>
      <div class="row"><div class="label">CRC32</div>   <div id="CRC32"   class="value" data-alg="CRC32" tabindex="0">入力待ち</div></div>
      <div class="row" id="row-Base64-enc" style="display:none;"><div class="label">Base64 Enc</div> <div id="Base64-Enc" class="value" data-alg="Base64 Enc" tabindex="0">入力待ち</div></div>
      <div class="row" id="row-Base64-dec" style="display:none;"><div class="label">Base64 Dec</div> <div id="Base64-Dec" class="value" data-alg="Base64 Dec" tabindex="0">入力待ち</div></div>
      <div class="row" id="row-Base85-enc" style="display:none;"><div class="label">Base85 Enc</div> <div id="Base85-Enc" class="value" data-alg="Base85 Enc" tabindex="0">入力待ち</div></div>
      <div class="row" id="row-Base85-dec" style="display:none;"><div class="label">Base85 Dec</div> <div id="Base85-Dec" class="value" data-alg="Base85 Dec" tabindex="0">入力待ち</div></div>
    </section>
  </main>
  <aside id="sys" class="sys">
    <div class="brandline">製造: ソニーグループ株式会社 / インターナショナル・ビジネス・マシーンズ・コーポレーション（IBM） 2026</div>
  </aside>
  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
/* =========================================================
   SECURITY LAYER — ZESS / Isolation Controls
========================================================= */
const Security = (() => {
  function init() {
    if (window.__ZESS_MODE__) {
      document.body.classList.add('airgap');
      window.fetch = async () => { throw new Error('ZESS: Egress Network Blocked'); };
      window.XMLHttpRequest = function() { throw new Error('ZESS: Egress Network Blocked'); };
      try { window.localStorage.clear(); } catch(e){}
      try { window.sessionStorage.clear(); } catch(e){}
      const dummyStorage = { getItem:()=>null, setItem:()=>{}, removeItem:()=>{}, clear:()=>{} };
      Object.defineProperty(window, 'localStorage', { value: dummyStorage, writable: false });
      Object.defineProperty(window, 'sessionStorage', { value: dummyStorage, writable: false });
      if (navigator.serviceWorker) navigator.serviceWorker.getRegistrations().then(r => r.forEach(x => x.unregister()));
      if (window.caches) { try { caches.keys().then(k => k.forEach(name => caches.delete(name))); } catch(e){} }
      if (window.indexedDB && window.indexedDB.databases) { try { indexedDB.databases().then(dbs => dbs.forEach(db => indexedDB.deleteDatabase(db.name))); } catch(e){} }
    }
  }
  return { init };
})();

/* =========================================================
   STATE LAYER — Application State Container
========================================================= */
const AppState = {
  theme: 'default',
  normalization: 'NFC',
  hexUpper: false,
  grouping: 0,
  Base64Encode: false,
  Base64Decode: false,
  Base85Encode: false,
  Base85Decode: false,
  currentFile: null,
  seq: 0,
  geoEnabled: false,
  geoLabel: '照会オフ',
  geoTs: 0,
  netTimeOffset: 0,
  battStr: window.__ZESS_MODE__ ? 'N/A (ZESS)' : 'N/A'
};

/* =========================================================
   CORE LAYER — Pure Algorithms (No DOM, No State)
========================================================= */
const Core = (() => {
  const enc = new TextEncoder();
  const subtle = crypto?.subtle;
  const seg = (window.Intl?.Segmenter) ? new Intl.Segmenter('ja',{granularity:'grapheme'}) : null;

  const HEX_LUT = Array.from({length: 256}, (_, i) => i.toString(16).padStart(2, '0'));

  async function safeAsync(fn, fallback = null) {
    try { return await fn(); } catch { return fallback; }
  }

  const toHex = buf => {
    const u8 = new Uint8Array(buf);
    let s = '';
    for (let i = 0; i < u8.length; i++) s += HEX_LUT[u8[i]];
    return s;
  };

  function encodeBase64(bytes) {
    let binary = '';
    const chunkSize = 8192;
    for (let i = 0; i < bytes.length; i += chunkSize) {
      binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
    }
    return btoa(binary);
  }

  const ZIP_SIGS = [
    { seq: [119, 111, 114, 100, 47], ext: 'docx', mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' },
    { seq: [120, 108, 47], ext: 'xlsx', mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' },
    { seq: [112, 112, 116, 47], ext: 'pptx', mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation' },
    { seq: [65, 110, 100, 114, 111, 105, 100, 77, 97, 110, 105, 102, 101, 115, 116, 46, 120, 109, 108], ext: 'apk', mime: 'application/vnd.android.package-archive' },
    { seq: [77, 69, 84, 65, 45, 73, 78, 70, 47], ext: 'jar', mime: 'application/java-archive' },
    { seq: [109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], ext: 'epub', mime: 'application/epub+zip' }
  ];

  function findByteSequence(haystack, needle, limit) {
    const max = Math.min(haystack.length, limit) - needle.length;
    const firstByte = needle[0];
    for (let i = 0; i <= max; i++) {
      if (haystack[i] !== firstByte) continue;
      let j = 1;
      while (j < needle.length && haystack[i + j] === needle[j]) j++;
      if (j === needle.length) return true;
    }
    return false;
  }

  function getFileInfo(bytes) {
    if (bytes.length >= 4) {
      const h = Array.from(bytes.subarray(0, 8)).map(b=>b.toString(16).padStart(2,'0')).join('');
      if (h.startsWith('89504e47')) return {ext: 'png', mime: 'image/png'};
      if (h.startsWith('ffd8ff')) return {ext: 'jpg', mime: 'image/jpeg'};
      if (h.startsWith('47494638')) return {ext: 'gif', mime: 'image/gif'};
      if (h.startsWith('25504446')) return {ext: 'pdf', mime: 'application/pdf'};
      if (h.startsWith('52617221')) return {ext: 'rar', mime: 'application/x-rar-compressed'};
      if (h.startsWith('00000100')) return {ext: 'ico', mime: 'image/x-icon'};
      if (h.startsWith('494433')) return {ext: 'mp3', mime: 'audio/mpeg'};
      if (h.startsWith('1a45dfa3')) return {ext: 'webm', mime: 'video/webm'};
      if (h.startsWith('4f676753')) return {ext: 'ogg', mime: 'audio/ogg'};
      
      if (bytes.length >= 12 && h.startsWith('52494646')) {
        const t = String.fromCharCode(...bytes.subarray(8, 12));
        if(t === 'WEBP') return {ext: 'webp', mime: 'image/webp'};
        if(t === 'WAVE') return {ext: 'wav', mime: 'audio/wav'};
        if(t === 'AVI ') return {ext: 'avi', mime: 'video/x-msvideo'};
      }

      if (h.startsWith('504b0304')) {
        const SCAN_LIMIT = 65536; 
        for (let i = 0; i < ZIP_SIGS.length; i++) {
          if (findByteSequence(bytes, ZIP_SIGS[i].seq, SCAN_LIMIT)) {
            return {ext: ZIP_SIGS[i].ext, mime: ZIP_SIGS[i].mime};
          }
        }
        return {ext: 'zip', mime: 'application/zip'};
      }
    }
    return {ext: 'bin', mime: 'application/octet-stream'};
  }

  function decodeBase64Info(str) {
    try {
      let clean = str.replace(/\s+/g, '');
      if (!clean) return { type: 'empty' };
      if (/[^A-Za-z0-9+/=_\-]/.test(clean)) return { type: 'error' };
      clean = clean.replace(/-/g, '+').replace(/_/g, '/');
      while (clean.length % 4 !== 0) clean += '=';
      const binary = atob(clean);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      try {
        const text = new TextDecoder('utf-8', {fatal: true}).decode(bytes);
        if (/[\x00-\x08\x0B\x0C\x0E-\x1F]/.test(text)) throw new Error('binary');
        return { type: 'text', value: text };
      } catch (e) {
        return { type: 'binary', bytes };
      }
    } catch (e) {
      return { type: 'error' };
    }
  }

  function applyGrouping(hex, groupSize) {
    const n = groupSize | 0;
    if(!n) return hex;
    return hex.replace(new RegExp(`(.{${n}})`, 'g'), '$1 ').trim();
  }

  function formatForDisplay(rawHex, hexUpper, groupSize) {
    const h = hexUpper ? rawHex.toUpperCase() : rawHex.toLowerCase();
    return applyGrouping(h, groupSize);
  }

  const CRC_TABLE = (()=>{const t=new Uint32Array(256);for(let i=0;i<256;i++){let c=i;for(let j=0;j<8;j++)c=(c&1)?(0xEDB88320^(c>>>1)):(c>>>1);t[i]=c>>>0;}return t;})();
  function crc32Hex(bytes){let c=0xFFFFFFFF;for(let i=0;i<bytes.length;i++){c=CRC_TABLE[(c^bytes[i])&0xFF]^(c>>>8);}return ((c^0xFFFFFFFF)>>>0).toString(16).padStart(8,'0');}

  function md5Hex(bytes){
    function rol(x,c){return (x<<c)|(x>>> (32-c))}
    function toWords(bytes){
      const len=bytes.length;
      const words=new Uint32Array((((len+8)>>>6)+1)*16);
      for(let i=0;i<len;i++) words[i>>2]|=bytes[i]<<((i%4)*8);
      const bitLen=len*8;
      words[len>>2]|=0x80<<((len%4)*8);
      words[words.length-2]=bitLen&0xffffffff;
      words[words.length-1]=(bitLen/0x100000000)|0;
      return words;
    }
    function ff(a,b,c,d,x,s,t){return b+rol((a+((b&c)|(~b&d))+x+t)|0,s)|0}
    function gg(a,b,c,d,x,s,t){return b+rol((a+((b&d)|(c&~d))+x+t)|0,s)|0}
    function hh(a,b,c,d,x,s,t){return b+rol((a+(b^c^d)+x+t)|0,s)|0}
    function ii(a,b,c,d,x,s,t){return b+rol((a+(c^(b|~d))+x+t)|0,s)|0}
    const x=toWords(bytes);let a=0x67452301,b=0xefcdab89,c=0x98badcfe,d=0x10325476;
    for(let i=0;i<x.length;i+=16){
      let A=a,B=b,C=c,D=d;
      a=ff(a,b,c,d,x[i+0],7,0xd76aa478); d=ff(d,a,b,c,x[i+1],12,0xe8c7b756); c=ff(c,d,a,b,x[i+2],17,0x242070db); b=ff(b,c,d,a,x[i+3],22,0xc1bdceee);
      a=ff(a,b,c,d,x[i+4],7,0xf57c0faf); d=ff(d,a,b,c,x[i+5],12,0x4787c62a); c=ff(c,d,a,b,x[i+6],17,0xa8304613); b=ff(b,c,d,a,x[i+7],22,0xfd469501);
      a=ff(a,b,c,d,x[i+8],7,0x698098d8); d=ff(d,a,b,c,x[i+9],12,0x8b44f7af); c=ff(c,d,a,b,x[i+10],17,0xffff5bb1); b=ff(b,c,d,a,x[i+11],22,0x895cd7be);
      a=ff(a,b,c,d,x[i+12],7,0x6b901122); d=ff(d,a,b,c,x[i+13],12,0xfd987193); c=ff(c,d,a,b,x[i+14],17,0xa679438e); b=ff(b,c,d,a,x[i+15],22,0x49b40821);
      a=gg(a,b,c,d,x[i+1],5,0xf61e2562); d=gg(d,a,b,c,x[i+6],9,0xc040b340); c=gg(c,d,a,b,x[i+11],14,0x265e5a51); b=gg(b,c,d,a,x[i+0],20,0xe9b6c7aa);
      a=gg(a,b,c,d,x[i+5],5,0xd62f105d); d=gg(d,a,b,c,x[i+10],9,0x02441453); c=gg(c,d,a,b,x[i+15],14,0xd8a1e681); b=gg(b,c,d,a,x[i+4],20,0xe7d3fbc8);
      a=gg(a,b,c,d,x[i+9],5,0x21e1cde6); d=gg(d,a,b,c,x[i+14],9,0xc33707d6); c=gg(c,d,a,b,x[i+3],14,0xf4d50d87); b=gg(b,c,d,a,x[i+8],20,0x455a14ed);
      a=gg(a,b,c,d,x[i+13],5,0xa9e3e905); d=gg(d,a,b,c,x[i+2],9,0xfcefa3f8); c=gg(c,d,a,b,x[i+7],14,0x676f02d9); b=gg(b,c,d,a,x[i+12],20,0x8d2a4c8a);
      a=hh(a,b,c,d,x[i+5],4,0xfffa3942); d=hh(d,a,b,c,x[i+8],11,0x8771f681); c=hh(c,d,a,b,x[i+11],16,0x6d9d6122); b=hh(b,c,d,a,x[i+14],23,0xfde5380c);
      a=hh(a,b,c,d,x[i+1],4,0xa4beea44); d=hh(d,a,b,c,x[i+4],11,0x4bdecfa9); c=hh(c,d,a,b,x[i+7],16,0xf6bb4b60); b=hh(b,c,d,a,x[i+10],23,0xbebfbc70);
      a=hh(a,b,c,d,x[i+13],4,0x289b7ec6); d=hh(d,a,b,c,x[i+0],11,0xeaa127fa); c=hh(c,d,a,b,x[3],16,0xd4ef3085); b=hh(b,c,d,a,x[6],23,0x04881d05);
      a=hh(a,b,c,d,x[i+9],4,0xd9d4d039); d=hh(d,a,b,c,x[i+12],11,0xe6db99e5); c=hh(c,d,a,b,x[i+15],16,0x1fa27cf8); b=hh(b,c,d,a,x[i+2],23,0xc4ac5665);
      a=ii(a,b,c,d,x[i+0],6,0xf4292244); d=ii(d,a,b,c,x[i+7],10,0x432aff97); c=ii(c,d,a,b,x[i+14],15,0xab9423a7); b=ii(b,c,d,a,x[i+5],21,0xfc93a039);
      a=ii(a,b,c,d,x[i+12],6,0x655b59c3); d=ii(d,a,b,c,x[i+3],10,0x8f0ccc92); c=ii(c,d,a,b,x[i+10],15,0xffeff47d); b=ii(b,c,d,a,x[i+1],21,0x85845dd1);
      a=ii(a,b,c,d,x[i+8],6,0x6fa87e4f); d=ii(d,a,b,c,x[i+15],10,0xfe2ce6e0); c=ii(c,d,a,b,x[i+6],15,0xa3014314); b=ii(b,c,d,a,x[i+13],21,0x4e0811a1);
      a=(a+A)|0; b=(b+B)|0; c=(c+C)|0; d=(d+D)|0;
    }
    const out=new Uint8Array(16),words=[a,b,c,d];
    for(let i=0;i<4;i++){out[i*4+0]=words[i]&255;out[i*4+1]=(words[i]>>>8)&255;out[i*4+2]=(words[i]>>>16)&255;out[i*4+3]=(words[i]>>>24)&255;}
    let res=''; for(let i=0; i<16; i++) res+=HEX_LUT[out[i]]; return res;
  }

  async function digestHex(alg, bytes){
    if(!subtle) throw new Error('Web Crypto API未対応');
    const buf = await subtle.digest(alg, bytes);
    return toHex(buf);
  }

  function countGraphemes(s){ return seg ? Array.from(seg.segment(s)).length : [...s].length; }
  
  function sanitizeText(s){
    s = s.replace(/[\u200B-\u200D\u2060\uFEFF]/g, '');
    s = s.replace(/\r\n?/g, '\n');
    return s;
  }

  function normalizeText(s, normMode){ 
    if(normMode==='none') return s; 
    try{ return s.normalize(normMode); } catch{ return s; } 
  }

  return { enc, safeAsync, encodeBase64, decodeBase64Info, getFileInfo, applyGrouping, formatForDisplay, crc32Hex, md5Hex, digestHex, countGraphemes, sanitizeText, normalizeText, HEX_LUT };
})();

/* =========================================================
   SYSTEM UTILS LAYER — Environment, Network, Time
========================================================= */
const SysUtils = (() => {
  const GEO_TTL = 12*60*60*1000;
  let _ipCache = { val:null, ts:0, ttl:120000 };

  const JP_PREF_MAP = {
    "Hokkaido":"北海道","Aomori":"青森県","Iwate":"岩手県","Miyagi":"宮城県","Akita":"秋田県","Yamagata":"山形県","Fukushima":"福島県",
    "Ibaraki":"茨城県","Tochigi":"栃木県","Gunma":"群馬県","Saitama":"埼玉県","Chiba":"千葉県","Tokyo":"東京都","Kanagawa":"神奈川県",
    "Niigata":"新潟県","Toyama":"富山県","Ishikawa":"石川県","Fukui":"福井県","Yamanashi":"山梨県","Nagano":"長野県",
    "Gifu":"岐阜県","Shizuoka":"静岡県","Aichi":"愛知県","Mie":"三重県",
    "Shiga":"滋賀県","Kyoto":"京都府","Osaka":"大阪府","Hyogo":"兵庫県","Nara":"奈良県","Wakayama":"和歌山県",
    "Tottori":"鳥取県","Shimane":"島根県","Okayama":"岡山県","Hiroshima":"広島県","Yamaguchi":"山口県",
    "Tokushima":"徳島県","Kagawa":"香川県","Ehime":"愛媛県","Kochi":"高知県",
    "Fukuoka":"福岡県","Saga":"佐賀県","Nagasaki":"長崎県","Kumamoto":"熊本県","Oita":"大分県","Miyazaki":"宮崎県","Kagoshima":"鹿児島県","Okinawa":"沖縄県"
  };

  const JP_PREF_BY_CODE = {
    "01":"北海道","02":"青森県","03":"岩手県","04":"宮城県","05":"秋田県","06":"山形県","07":"福島県",
    "08":"茨城県","09":"栃木県","10":"群馬県","11":"埼玉県","12":"千葉県","13":"東京都","14":"神奈川県",
    "15":"新潟県","16":"富山県","17":"石川県","18":"福井県","19":"山梨県","20":"長野県",
    "21":"岐阜県","22":"静岡県","23":"愛知県","24":"三重県",
    "25":"滋賀県","26":"京都府","27":"大阪府","28":"兵庫県","29":"奈良県","30":"和歌山県",
    "31":"鳥取県","32":"島根県","33":"岡山県","34":"広島県","35":"山口県",
    "36":"徳島県","37":"香川県","38":"愛媛県","39":"高知県",
    "40":"福岡県","41":"佐賀県","42":"長崎県","43":"熊本県","44":"大分県","45":"宮崎県","46":"鹿児島県","47":"沖縄県"
  };

  const TOKYO_WARD_MAP = {
    Chiyoda:"千代田区", Chuo:"中央区", Minato:"港区", Shinjuku:"新宿区", Bunkyo:"文京区",
    Taito:"台東区", Sumida:"墨田区", Koto:"江東区", Shinagawa:"品川区", Meguro:"目黒区",
    Ota:"大田区", Setagaya:"世田谷区", Shibuya:"渋谷区", Nakano:"中野区", Suginami:"杉並区",
    Toshima:"豊島区", Kita:"北区", Arakawa:"荒川区", Itabashi:"板橋区", Nerima:"練馬区",
    Adachi:"足立区", Katsushika:"葛飾区", Edogawa:"江戸川区"
  };

  const CITY_MAJOR_MAP = {
    Sapporo:"札幌市", Sendai:"仙台市", Saitama:"さいたま市", Chiba:"千葉市",
    Yokohama:"横浜市", Kawasaki:"川崎市", Sagamihara:"相模原市",
    Niigata:"新潟市", Shizuoka:"静岡市", Hamamatsu:"浜松市",
    Nagoya:"名古屋市", Kyoto:"京都市", Osaka:"大阪市", Sakai:"堺市",
    Kobe:"神戸市", Okayama:"岡山市", Hiroshima:"広島市",
    Kitakyushu:"北九州市", Fukuoka:"福岡市", Kumamoto:"熊本市"
  };

  function fmtJapaneseDate(d){
    try{
      const f=new Intl.DateTimeFormat('ja-JP-u-ca-japanese',{year:'numeric',month:'long',day:'numeric',weekday:'long',hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false,timeZone:'Asia/Tokyo'});
      return f.format(d);
    }catch(_){
      const y=d.getFullYear(),m=d.getMonth()+1,day=d.getDate(),w=['日','月','火','水','木','金','土'][d.getDay()];
      let era='西暦',ey=y; const reiwaStart=new Date(Date.UTC(2019,4,1)),heiseiStart=new Date(Date.UTC(1989,0,8)),dt=new Date(Date.UTC(y,m-1,day));
      if(dt>=reiwaStart){era='令和';ey=y-2018;} else if(dt>=heiseiStart){era='平成';ey=y-1988;}
      return `${era}${ey}年${m}月${day}日（${w}） ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
    }
  }

  function deviceInfo(){
    const ua=navigator.userAgent||'';
    const plat=(navigator.userAgentData&&navigator.userAgentData.platform)||navigator.platform||'';
    const brands=(navigator.userAgentData&&navigator.userAgentData.brands||[]).map(b=>`${b.brand}/${b.version}`).join(', ');
    const vendor=navigator.vendor||'';
    const dpr=window.devicePixelRatio||1;
    const vw=Math.round(window.innerWidth),vh=Math.round(window.innerHeight);
    const sw=screen.width,sh=screen.height;
    const mem=navigator.deviceMemory?`${navigator.deviceMemory}GB`:'N/A';
    const cores=navigator.hardwareConcurrency?`${navigator.hardwareConcurrency}コア`:'N/A';
    const dev=/Android|iPhone|iPad|iPod|Mobile/i.test(ua)?'モバイル':'デスクトップ';
    return [
      `スクリーン: ${sw}×${sh} @${dpr}x`,
      `ビューポート: ${vw}×${vh}`,
      `システム: ${plat||'N/A'}`,
      `デバイス: ${dev}`,
      `ベンダー: ${vendor||'N/A'}`,
      `ブランド: ${brands||'N/A'}`,
      `CPU: ${cores} / メモリ: ${mem}`,
      `電源: ${AppState.battStr}`
    ].join('\n');
  }

  async function publicIP(){
    if(window.__ZESS_MODE__) return 'ZESS: ネットワーク遮断';
    if(!navigator.onLine) return 'オフライン利用';
    const now = performance.now();
    if(_ipCache.val && (now - _ipCache.ts) < _ipCache.ttl) return _ipCache.val;
    try{
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), 3000);
      const r = await fetch('https://api.ipify.org?format=json',{signal:ctrl.signal});
      clearTimeout(t);
      if(!r.ok) throw new Error('ipify error');
      const {ip} = await r.json();
      const isV6 = ip.includes(':');
      _ipCache = { val:`IP: ${ip} [${isV6?'IPv6':'IPv4'}]`, ts: now, ttl:_ipCache.ttl };
      return _ipCache.val;
    }catch(_){ return 'ネットワーク: 不明（オンライン検出）'; }
  }

  async function networkDetail(){
    if(window.__ZESS_MODE__) return '接続: ZESS Enclave (No Egress)';
    const c=navigator.connection||navigator.mozConnection||navigator.webkitConnection;
    const base=c?`接続: ${c.effectiveType||'N/A'} 下り:${c.downlink||'?'}Mbps RTT:${c.rtt||'?'}ms`:'接続: N/A';
    const ip=await publicIP();
    return `${base}\n${ip}`;
  }

  function formatPostalJP(z){
    const s = String(z||'').replace(/\D/g,'');
    return s.length===7 ? `${s.slice(0,3)}-${s.slice(3)}` : (s||'');
  }

  function jpCityLabel(prefJa, cityEn){
    let c = String(cityEn||'').trim();
    if(!c) return '';
    if(prefJa==='東京都'){
      if(/^tokyo(?:-to)?$/i.test(c)) return '';
      if(TOKYO_WARD_MAP[c]) return TOKYO_WARD_MAP[c];
    }
    if(CITY_MAJOR_MAP[c]) return CITY_MAJOR_MAP[c];
    c = c.replace(/-?ku$/i,'区').replace(/-?shi$/i,'市').replace(/-?gun$/i,'郡').replace(/-?chou?$/i,'町').replace(/-?machi$/i,'町').replace(/-?mura$/i,'村').replace(/-?son$/i,'村');
    if(/区|市|郡|町|村$/.test(c)) return c;
    return `${c}市`;
  }

  function mapPref(region, code){
    const r = String(region||'').trim();
    let c2 = String(code||'').trim();
    c2 = /^\d+$/.test(c2) ? c2.padStart(2,'0') : c2.replace(/\D+/g,'').padStart(2,'0');
    if(JP_PREF_MAP[r]) return JP_PREF_MAP[r];
    const alt = r.replace(/\s*(Prefecture|都|道|府|県)$/i,'');
    if(JP_PREF_MAP[alt]) return JP_PREF_MAP[alt];
    if(JP_PREF_BY_CODE[c2]) return JP_PREF_BY_CODE[c2];
    return r || '不明';
  }

  async function fetchJson(url, timeoutMs){
    if(window.__ZESS_MODE__) throw new Error('ZESS Blocked');
    const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(), timeoutMs);
    try{
      const res = await fetch(url,{signal:ctrl.signal});
      clearTimeout(t);
      if(!res.ok) throw new Error('bad status');
      const ct = res.headers.get('content-type')||'';
      return ct.includes('application/json') ? await res.json() : await res.text();
    }catch(e){ clearTimeout(t); throw e; }
  }

  async function detectGeo(timeoutMs=3500){
    if(window.__ZESS_MODE__) return 'ZESS (位置情報隔離)';
    if(!AppState.geoEnabled) return '照会オフ';
    if(!navigator.onLine) return 'オフライン利用';
    const now = Date.now();
    if(AppState.geoLabel && (now - AppState.geoTs) < GEO_TTL && AppState.geoLabel!=='不明') return AppState.geoLabel;
    const providers = [
      { url:'https://ipapi.co/json/', pick:j=>({cc:j.country_code||j.country, region:j.region, code:j.region_code, city:j.city, postal:j.postal, isp:j.org}) },
      { url:'https://ipwho.is/',     pick:j=>({cc:j.country_code,          region:j.region, code:'',             city:j.city, postal:j.postal, isp:j.connection?.isp||j.connection?.org}) },
      { url:'https://ipinfo.io/json',pick:j=>({cc:j.country,                region:j.region, code:'',             city:j.city, postal:j.postal, isp:j.org}) },
      { url:'https://www.cloudflare.com/cdn-cgi/trace', pick:t=>{ const m=/\bloc=([A-Z]{2})/m.exec(t)||[]; return {cc:m[1]||'', region:'', code:'', city:'', postal:'', isp:''}; } },
      { url:'https://ip-api.com/json/?fields=status,countryCode,region,regionName,city,zip,isp,org,as', pick:j=>({cc:j.countryCode, region:j.regionName, code:j.region, city:j.city, postal:j.zip, isp:j.isp||j.org||j.as}) }
    ];
    for(const p of providers){
      try{
        const raw = await fetchJson(p.url, timeoutMs);
        const d = p.pick(raw);
        const cc = String(d.cc||'').toUpperCase();
        if(cc==='JP'){
          const prefJa = mapPref(d.region||'', d.code||'');
          const cityJa = jpCityLabel(prefJa, d.city||'');
          const postal = formatPostalJP(d.postal||'');
          let label = `日本・${prefJa}`;
          if(cityJa) label += `・${cityJa}`;
          if(postal) label += `（〒${postal}）`;
          if(d.isp) {
            let ispClean = String(d.isp).replace(/^AS\d+\s*/i, '').replace(/,.*/, '').trim();
            if(ispClean) label += ` [${ispClean}]`;
          }
          AppState.geoLabel = label; AppState.geoTs = now;
          return label;
        }else if(cc){
          AppState.geoLabel = '圏外'; AppState.geoTs = now;
          return AppState.geoLabel;
        }
      }catch(_){}
    }
    AppState.geoLabel = '不明'; AppState.geoTs = now;
    return AppState.geoLabel;
  }

  async function syncNetworkTime(){
    if(window.__ZESS_MODE__ || !navigator.onLine){ AppState.netTimeOffset=0; return; }
    try{
      const ctrl=new AbortController();const t=setTimeout(()=>ctrl.abort(),3000);
      const r=await fetch('https://worldtimeapi.org/api/timezone/Asia/Tokyo',{signal:ctrl.signal});clearTimeout(t);
      if(!r.ok) throw new Error('time api error');
      const j=await r.json();const server=new Date(j.datetime).getTime();const local=Date.now(); AppState.netTimeOffset=server-local;
    }catch(_){ AppState.netTimeOffset=0; }
  }

  function resetIpCache() { _ipCache.ts = 0; }

  return { fmtJapaneseDate, deviceInfo, publicIP, networkDetail, detectGeo, syncNetworkTime, resetIpCache };
})();

/* =========================================================
   BASE85 (Z85) ENGINE LAYER — Dedicated Worker
========================================================= */
const Base85Engine = (() => {
  let worker = null;
  function init() {
    if(worker) return;
    const code = `
      // Z85 (ZeroMQ Base-85) Charset
      const CHARSET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#'.split('');
      const DECODE_MAP = new Uint8Array(256);
      for(let i=0; i<85; i++) DECODE_MAP[CHARSET[i].charCodeAt(0)] = i;

      function encodeZ85(bytes) {
        const len = bytes.length;
        const extra = len % 4;
        const paddedLen = extra === 0 ? len : len + (4 - extra);
        const data = new Uint8Array(paddedLen);
        data.set(bytes);
        const view = new DataView(data.buffer);
        let res = '';
        for(let i=0; i<paddedLen; i+=4) {
          let val = view.getUint32(i, false);
          let chunk = '';
          for(let j=0; j<5; j++) {
            chunk = CHARSET[val % 85] + chunk;
            val = Math.floor(val / 85);
          }
          res += chunk;
        }
        return extra === 0 ? res : res.slice(0, res.length - (4 - extra));
      }

      function decodeZ85(str) {
        const clean = str.replace(/\\s+/g, '');
        if(!clean) return new Uint8Array(0);
        const len = clean.length;
        const extra = len % 5;
        const paddedLen = extra === 0 ? len : len + (5 - extra);
        let workStr = clean;
        if(extra > 0) {
          workStr += CHARSET[84].repeat(5 - extra);
        }
        const out = new Uint8Array((paddedLen / 5) * 4);
        const view = new DataView(out.buffer);
        for(let i=0; i<paddedLen; i+=5) {
          let val = 0;
          for(let j=0; j<5; j++) {
            val = val * 85 + DECODE_MAP[workStr.charCodeAt(i+j)];
          }
          view.setUint32((i/5)*4, val, false);
        }
        return extra === 0 ? out : out.slice(0, out.length - (5 - extra));
      }

      onmessage = function(e) {
        const { action, payload, reqId } = e.data;
        try {
          if(action === 'encode') {
            const str = encodeZ85(payload);
            postMessage({ reqId, status: 'ok', result: { type: 'text', value: str } });
          } else if(action === 'decode') {
            const clean = payload.replace(/\\s+/g, '');
            const invalid = /[^0-9a-zA-Z\\.\\-\\:\\+\\=\\^\\!\\/\\*\\?\\&\\<\\>\\(\\)\\[\\]\\{\\}\\@\\%\\$\\#]/;
            if(invalid.test(clean)) throw new Error('Invalid Z85 Characters');
            const bytes = decodeZ85(payload);
            try {
              const text = new TextDecoder('utf-8', {fatal: true}).decode(bytes);
              if (/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/.test(text)) throw new Error('binary');
              postMessage({ reqId, status: 'ok', result: { type: 'text', value: text } });
            } catch(err) {
              postMessage({ reqId, status: 'ok', result: { type: 'binary', bytes } }, [bytes.buffer]);
            }
          }
        } catch(err) {
          postMessage({ reqId, status: 'error', error: err.message });
        }
      };
    `;
    const blob = new Blob([code], {type:'application/javascript'});
    worker = new Worker(URL.createObjectURL(blob));
  }

  function run(action, payload) {
    return new Promise((resolve) => {
      init();
      const reqId = Date.now() + Math.random();
      const handler = (e) => {
        if(e.data.reqId === reqId) {
          worker.removeEventListener('message', handler);
          if(e.data.status === 'ok') resolve(e.data.result);
          else resolve({ type: 'error', message: e.data.error });
        }
      };
      worker.addEventListener('message', handler);
      if(action === 'encode') {
        const copy = new Uint8Array(payload).buffer;
        worker.postMessage({ action, payload: new Uint8Array(copy), reqId }, [copy]);
      } else {
        worker.postMessage({ action, payload, reqId });
      }
    });
  }
  
  function terminate() {
    if(worker) { worker.terminate(); worker = null; }
  }

  return { encode: bytes => run('encode', bytes), decode: str => run('decode', str), terminate };
})();

/* =========================================================
   ENGINE LAYER — Hash Execution & Worker Control
========================================================= */
const Engine = (() => {
  const WORKER_THRESHOLD = 200000;
  const hasWorker = !!window.Worker;
  let workerUrl = null;
  let worker = null;

  function createWorkerBlob() {
    if (workerUrl) { try { URL.revokeObjectURL(workerUrl); } catch(e){} }
    const code = `
      const HEX_LUT = [${Array.from({length: 256}, (_, i) => "'" + i.toString(16).padStart(2, '0') + "'").join(',')}];
      const CRC_TABLE = (()=>{const t=new Uint32Array(256);for(let i=0;i<256;i++){let c=i;for(let j=0;j<8;j++)c=(c&1)?(0xEDB88320^(c>>>1)):(c>>>1);t[i]=c>>>0;}return t;})();
      function crc32Hex(bytes){let c=0xFFFFFFFF;for(let i=0;i<bytes.length;i++){c=CRC_TABLE[(c^bytes[i])&0xFF]^(c>>>8);}return ((c^0xFFFFFFFF)>>>0).toString(16).padStart(8,'0');}
      function rol(x,c){return (x<<c)|(x>>> (32-c))}
      function ff(a,b,c,d,x,s,t){return b+rol((a+((b&c)|(~b&d))+x+t)|0,s)|0}
      function gg(a,b,c,d,x,s,t){return b+rol((a+((b&d)|(c&~d))+x+t)|0,s)|0}
      function hh(a,b,c,d,x,s,t){return b+rol((a+(b^c^d)+x+t)|0,s)|0}
      function ii(a,b,c,d,x,s,t){return b+rol((a+(c^(b|~d))+x+t)|0,s)|0}
      function sha1Process(h, w) {
        let a=h[0], b=h[1], c=h[2], d=h[3], e=h[4];
        for(let i=0; i<80; i++) {
          if(i>=16) w[i] = rol(w[i-3]^w[i-8]^w[i-14]^w[i-16], 1);
          let f, k;
          if(i<20) { f = (b&c)|((~b)&d); k = 0x5A827999; }
          else if(i<40) { f = b^c^d; k = 0x6ED9EBA1; }
          else if(i<60) { f = (b&c)|(b&d)|(c&d); k = 0x8F1BBCDC; }
          else { f = b^c^d; k = 0xCA62C1D6; }
          let temp = (rol(a,5) + f + e + k + w[i])|0;
          e=d; d=c; c=rol(b,30); b=a; a=temp;
        }
        h[0]=(h[0]+a)|0; h[1]=(h[1]+b)|0; h[2]=(h[2]+c)|0; h[3]=(h[3]+d)|0; h[4]=(h[4]+e)|0;
      }
      const SHA256_K = new Uint32Array([0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2]);
      function sha256Process(h, w) {
        let a=h[0], b=h[1], c=h[2], d=h[3], e=h[4], f=h[5], g=h[6], _h=h[7];
        for(let i=0; i<64; i++) {
          if(i>=16) {
            let w15=w[i-15], w2=w[i-2];
            let s0 = (w15>>>7 | w15<<25) ^ (w15>>>18 | w15<<14) ^ (w15>>>3);
            let s1 = (w2>>>17 | w2<<15) ^ (w2>>>19 | w2<<13) ^ (w2>>>10);
            w[i] = (w[i-16] + s0 + w[i-7] + s1)|0;
          }
          let S1 = (e>>>6 | e<<26) ^ (e>>>11 | e<<21) ^ (e>>>25 | e<<7);
          let ch = (e&f) ^ ((~e)&g);
          let temp1 = (_h + S1 + ch + SHA256_K[i] + w[i])|0;
          let S0 = (a>>>2 | a<<30) ^ (a>>>13 | a<<19) ^ (a>>>22 | a<<10);
          let maj = (a&b) ^ (a&c) ^ (b&c);
          let temp2 = (S0 + maj)|0;
          _h=g; g=f; f=e; e=(d+temp1)|0; d=c; c=b; b=a; a=(temp1+temp2)|0;
        }
        h[0]=(h[0]+a)|0; h[1]=(h[1]+b)|0; h[2]=(h[2]+c)|0; h[3]=(h[3]+d)|0;
        h[4]=(h[4]+e)|0; h[5]=(h[5]+f)|0; h[6]=(h[6]+g)|0; h[7]=(h[7]+_h)|0;
      }
      class IncrementalHasher {
        constructor() {
          this.md5_h = new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
          this.sha1_h = new Uint32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
          this.sha256_h = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
          this.crc = 0xFFFFFFFF;
          this.buffer = new Uint8Array(64);
          this.bufLen = 0;
          this.totalLen = 0;
          this.wMD5 = new Uint32Array(16);
          this.wSHA = new Uint32Array(80);
        }
        update(bytes) {
          let crc = this.crc;
          for(let i=0; i<bytes.length; i++) crc = CRC_TABLE[(crc ^ bytes[i]) & 0xFF] ^ (crc >>> 8);
          this.crc = crc;
          let offset = 0;
          let len = bytes.length;
          this.totalLen += len;
          if (this.bufLen > 0) {
            const take = Math.min(64 - this.bufLen, len);
            this.buffer.set(bytes.subarray(0, take), this.bufLen);
            this.bufLen += take;
            offset += take;
            if (this.bufLen === 64) {
              this._process(this.buffer, 0);
              this.bufLen = 0;
            }
          }
          while (offset + 64 <= len) {
            this._process(bytes, offset);
            offset += 64;
          }
          if (offset < len) {
            this.buffer.set(bytes.subarray(offset), 0);
            this.bufLen = len - offset;
          }
        }
        _process(arr, off) {
          const wMD5 = this.wMD5, wSHA = this.wSHA;
          for(let i=0; i<16; i++) {
            let p = off + i*4;
            wMD5[i] = arr[p] | (arr[p+1]<<8) | (arr[p+2]<<16) | (arr[p+3]<<24);
            wSHA[i] = (arr[p]<<24) | (arr[p+1]<<16) | (arr[p+2]<<8) | arr[p+3];
          }
          let a=this.md5_h[0], b=this.md5_h[1], c=this.md5_h[2], d=this.md5_h[3], x=wMD5;
          a=ff(a,b,c,d,x[0],7,0xd76aa478); d=ff(d,a,b,c,x[1],12,0xe8c7b756); c=ff(c,d,a,b,x[2],17,0x242070db); b=ff(b,c,d,a,x[3],22,0xc1bdceee);
          a=ff(a,b,c,d,x[4],7,0xf57c0faf); d=ff(d,a,b,c,x[5],12,0x4787c62a); c=ff(c,d,a,b,x[6],17,0xa8304613); b=ff(b,c,d,a,x[7],22,0xfd469501);
          a=ff(a,b,c,d,x[8],7,0x698098d8); d=ff(d,a,b,c,x[9],12,0x8b44f7af); c=ff(c,d,a,b,x[10],17,0xffff5bb1); b=ff(b,c,d,a,x[11],22,0x895cd7be);
          a=ff(a,b,c,d,x[12],7,0x6b901122); d=ff(d,a,b,c,x[13],12,0xfd987193); c=ff(c,d,a,b,x[14],17,0xa679438e); b=ff(b,c,d,a,x[15],22,0x49b40821);
          a=gg(a,b,c,d,x[1],5,0xf61e2562); d=gg(d,a,b,c,x[6],9,0xc040b340); c=gg(c,d,a,b,x[11],14,0x265e5a51); b=gg(b,c,d,a,x[0],20,0xe9b6c7aa);
          a=gg(a,b,c,d,x[5],5,0xd62f105d); d=gg(d,a,b,c,x[10],9,0x02441453); c=gg(c,d,a,b,x[15],14,0xd8a1e681); b=gg(b,c,d,a,x[4],20,0xe7d3fbc8);
          a=gg(a,b,c,d,x[9],5,0x21e1cde6); d=gg(d,a,b,c,x[14],9,0xc33707d6); c=gg(c,d,a,b,x[3],14,0xf4d50d87); b=gg(b,c,d,a,x[8],20,0x455a14ed);
          a=gg(a,b,c,d,x[13],5,0xa9e3e905); d=gg(d,a,b,c,x[2],9,0xfcefa3f8); c=gg(c,d,a,b,x[7],14,0x676f02d9); b=gg(b,c,d,a,x[12],20,0x8d2a4c8a);
          a=hh(a,b,c,d,x[5],4,0xfffa3942); d=hh(d,a,b,c,x[8],11,0x8771f681); c=hh(c,d,a,b,x[11],16,0x6d9d6122); b=hh(b,c,d,a,x[14],23,0xfde5380c);
          a=hh(a,b,c,d,x[1],4,0xa4beea44); d=hh(d,a,b,c,x[4],11,0x4bdecfa9); c=hh(c,d,a,b,x[7],16,0xf6bb4b60); b=hh(b,c,d,a,x[10],23,0xbebfbc70);
          a=hh(a,b,c,d,x[13],4,0x289b7ec6); d=hh(d,a,b,c,x[0],11,0xeaa127fa); c=hh(c,d,a,b,x[3],16,0xd4ef3085); b=hh(b,c,d,a,x[6],23,0x04881d05);
          a=hh(a,b,c,d,x[9],4,0xd9d4d039); d=hh(d,a,b,c,x[12],11,0xe6db99e5); c=hh(c,d,a,b,x[15],16,0x1fa27cf8); b=hh(b,c,d,a,x[2],23,0xc4ac5665);
          a=ii(a,b,c,d,x[0],6,0xf4292244); d=ii(d,a,b,c,x[7],10,0x432aff97); c=ii(c,d,a,b,x[14],15,0xab9423a7); b=ii(b,c,d,a,x[5],21,0xfc93a039);
          a=ii(a,b,c,d,x[12],6,0x655b59c3); d=ii(d,a,b,c,x[3],10,0x8f0ccc92); c=ii(c,d,a,b,x[10],15,0xffeff47d); b=ii(b,c,d,a,x[1],21,0x85845dd1);
          a=ii(a,b,c,d,x[8],6,0x6fa87e4f); d=ii(d,a,b,c,x[15],10,0xfe2ce6e0); c=ii(c,d,a,b,x[6],15,0xa3014314); b=ii(b,c,d,a,x[13],21,0x4e0811a1);
          this.md5_h[0]=(this.md5_h[0]+a)|0; this.md5_h[1]=(this.md5_h[1]+b)|0; this.md5_h[2]=(this.md5_h[2]+c)|0; this.md5_h[3]=(this.md5_h[3]+d)|0;
          sha1Process(this.sha1_h, wSHA);
          sha256Process(this.sha256_h, wSHA);
        }
        finalize() {
          const md5Final = this._finalizeMD5();
          const sha1Final = this._finalizeSHA(this.sha1_h, sha1Process, 20);
          const sha256Final = this._finalizeSHA(this.sha256_h, sha256Process, 32);
          const crcHex = ((this.crc ^ 0xFFFFFFFF) >>> 0).toString(16).padStart(8, '0');
          return { md5: md5Final, sha1: sha1Final, sha256: sha256Final, crc: crcHex };
        }
        _finalizeMD5() {
          const padLen = (this.bufLen < 56) ? (64 - this.bufLen) : (128 - this.bufLen);
          const pad = new Uint8Array(padLen);
          pad[0] = 0x80;
          const view = new DataView(pad.buffer);
          const bitLen = this.totalLen * 8;
          view.setUint32(padLen - 8, bitLen & 0xffffffff, true);
          view.setUint32(padLen - 4, Math.floor(this.totalLen / 0x20000000), true);
          let full = new Uint8Array(this.bufLen + padLen);
          full.set(this.buffer.subarray(0, this.bufLen));
          full.set(pad, this.bufLen);
          let h = new Uint32Array(this.md5_h);
          const w = new Uint32Array(16);
          for(let offset=0; offset<full.length; offset+=64) {
            for(let i=0; i<16; i++) {
              let p = offset + i*4;
              w[i] = full[p] | (full[p+1]<<8) | (full[p+2]<<16) | (full[p+3]<<24);
            }
            let a=h[0], b=h[1], c=h[2], d=h[3], x=w;
            a=ff(a,b,c,d,x[0],7,0xd76aa478); d=ff(d,a,b,c,x[1],12,0xe8c7b756); c=ff(c,d,a,b,x[2],17,0x242070db); b=ff(b,c,d,a,x[3],22,0xc1bdceee);
            a=ff(a,b,c,d,x[4],7,0xf57c0faf); d=ff(d,a,b,c,x[5],12,0x4787c62a); c=ff(c,d,a,b,x[6],17,0xa8304613); b=ff(b,c,d,a,x[7],22,0xfd469501);
            a=ff(a,b,c,d,x[8],7,0x698098d8); d=ff(d,a,b,c,x[9],12,0x8b44f7af); c=ff(c,d,a,b,x[10],17,0xffff5bb1); b=ff(b,c,d,a,x[11],22,0x895cd7be);
            a=ff(a,b,c,d,x[12],7,0x6b901122); d=ff(d,a,b,c,x[13],12,0xfd987193); c=ff(c,d,a,b,x[14],17,0xa679438e); b=ff(b,c,d,a,x[15],22,0x49b40821);
            a=gg(a,b,c,d,x[1],5,0xf61e2562); d=gg(d,a,b,c,x[6],9,0xc040b340); c=gg(c,d,a,b,x[11],14,0x265e5a51); b=gg(b,c,d,a,x[0],20,0xe9b6c7aa);
            a=gg(a,b,c,d,x[5],5,0xd62f105d); d=gg(d,a,b,c,x[10],9,0x02441453); c=gg(c,d,a,b,x[15],14,0xd8a1e681); b=gg(b,c,d,a,x[4],20,0xe7d3fbc8);
            a=gg(a,b,c,d,x[9],5,0x21e1cde6); d=gg(d,a,b,c,x[14],9,0xc33707d6); c=gg(c,d,a,b,x[3],14,0xf4d50d87); b=gg(b,c,d,a,x[8],20,0x455a14ed);
            a=gg(a,b,c,d,x[13],5,0xa9e3e905); d=gg(d,a,b,c,x[2],9,0xfcefa3f8); c=gg(c,d,a,b,x[7],14,0x676f02d9); b=gg(b,c,d,a,x[12],20,0x8d2a4c8a);
            a=hh(a,b,c,d,x[5],4,0xfffa3942); d=hh(d,a,b,c,x[8],11,0x8771f681); c=hh(c,d,a,b,x[11],16,0x6d9d6122); b=hh(b,c,d,a,x[14],23,0xfde5380c);
            a=hh(a,b,c,d,x[1],4,0xa4beea44); d=hh(d,a,b,c,x[4],11,0x4bdecfa9); c=hh(c,d,a,b,x[7],16,0xf6bb4b60); b=hh(b,c,d,a,x[10],23,0xbebfbc70);
            a=hh(a,b,c,d,x[13],4,0x289b7ec6); d=hh(d,a,b,c,x[0],11,0xeaa127fa); c=hh(c,d,a,b,x[3],16,0xd4ef3085); b=hh(b,c,d,a,x[6],23,0x04881d05);
            a=hh(a,b,c,d,x[9],4,0xd9d4d039); d=hh(d,a,b,c,x[12],11,0xe6db99e5); c=hh(c,d,a,b,x[15],16,0x1fa27cf8); b=hh(b,c,d,a,x[2],23,0xc4ac5665);
            a=ii(a,b,c,d,x[0],6,0xf4292244); d=ii(d,a,b,c,x[7],10,0x432aff97); c=ii(c,d,a,b,x[14],15,0xab9423a7); b=ii(b,c,d,a,x[5],21,0xfc93a039);
            a=ii(a,b,c,d,x[12],6,0x655b59c3); d=ii(d,a,b,c,x[3],10,0x8f0ccc92); c=ii(c,d,a,b,x[10],15,0xffeff47d); b=ii(b,c,d,a,x[1],21,0x85845dd1);
            a=ii(a,b,c,d,x[8],6,0x6fa87e4f); d=ii(d,a,b,c,x[15],10,0xfe2ce6e0); c=ii(c,d,a,b,x[6],15,0xa3014314); b=ii(b,c,d,a,x[13],21,0x4e0811a1);
            h[0]=(h[0]+a)|0; h[1]=(h[1]+b)|0; h[2]=(h[2]+c)|0; h[3]=(h[3]+d)|0;
          }
          const out = new Uint8Array(16);
          const view2 = new DataView(out.buffer);
          view2.setUint32(0, h[0], true); view2.setUint32(4, h[1], true);
          view2.setUint32(8, h[2], true); view2.setUint32(12, h[3], true);
          let res = '';
          for (let i = 0; i < 16; i++) res += HEX_LUT[out[i]];
          return res;
        }
        _finalizeSHA(origH, processFn, outBytes) {
          const padLen = (this.bufLen < 56) ? (64 - this.bufLen) : (128 - this.bufLen);
          const pad = new Uint8Array(padLen);
          pad[0] = 0x80;
          const view = new DataView(pad.buffer);
          const bitLen = this.totalLen * 8;
          view.setUint32(padLen - 8, Math.floor(this.totalLen / 0x20000000), false);
          view.setUint32(padLen - 4, bitLen & 0xffffffff, false);
          let full = new Uint8Array(this.bufLen + padLen);
          full.set(this.buffer.subarray(0, this.bufLen));
          full.set(pad, this.bufLen);
          let h = new Uint32Array(origH);
          const w = new Uint32Array(80);
          for(let offset=0; offset<full.length; offset+=64) {
            for(let i=0; i<16; i++) {
              let p = offset + i*4;
              w[i] = (full[p]<<24) | (full[p+1]<<16) | (full[p+2]<<8) | full[p+3];
            }
            processFn(h, w);
          }
          const out = new Uint8Array(outBytes);
          const view2 = new DataView(out.buffer);
          for(let i=0; i<outBytes/4; i++) view2.setUint32(i*4, h[i], false);
          let res = '';
          for (let i = 0; i < outBytes; i++) res += HEX_LUT[out[i]];
          return res;
        }
      }
      ${Core.md5Hex.toString()}
      let hasher = null;
      onmessage = e => {
        const { action, bytes } = e.data;
        if (action === 'init') { hasher = new IncrementalHasher(); }
        else if (action === 'update') { if(hasher) hasher.update(bytes); }
        else if (action === 'finalize') { if(hasher) postMessage(hasher.finalize()); hasher = null; }
        else if (action === 'hashAll') {
          const temp = new IncrementalHasher();
          temp.update(bytes);
          postMessage(temp.finalize());
        }
      };
    `;
    const blob = new Blob([code], {type:'application/javascript'});
    workerUrl = URL.createObjectURL(blob);
    return new Worker(workerUrl);
  }

  function ensureWorker() {
    if (hasWorker && !worker) { worker = createWorkerBlob(); }
  }

  function terminateWorker() {
    if (worker) { worker.terminate(); worker = null; }
  }

  async function hashFile(file, curSeq, onUpdate) {
    const isSmallFile = file.size <= 50 * 1024 * 1024;
    return new Promise(async resolve => {
      let completed = 0;
      const target = isSmallFile ? 2 : 1;
      const checkDone = () => { completed++; if (completed >= target) resolve(); };

      if (hasWorker && file.stream) {
        worker.onerror = () => {
          const errRes = {'MD5':'ワーカーエラー', 'SHA-1':'ワーカーエラー', 'SHA-256':'ワーカーエラー', 'CRC32':'ワーカーエラー'};
          if (isSmallFile) {
            errRes['SHA-384'] = 'ワーカーエラー'; errRes['SHA-512'] = 'ワーカーエラー';
            if (AppState.Base64Encode) errRes['Base64-Enc'] = 'ワーカーエラー';
            if (AppState.Base85Encode) errRes['Base85-Enc'] = 'ワーカーエラー';
          }
          onUpdate(errRes);
          checkDone();
          if (isSmallFile) checkDone();
          terminateWorker();
          ensureWorker();
        };

        worker.onmessage = ev => {
          const {md5, sha1, sha256, crc} = ev.data;
          onUpdate({'MD5': md5, 'SHA-1': sha1, 'SHA-256': sha256, 'CRC32': crc});
          checkDone();
        };

        worker.postMessage({action: 'init'});
        const stream = file.stream();
        const reader = stream.getReader();
        let fullBuffer = isSmallFile ? new Uint8Array(file.size) : null;
        let offset = 0;
        let bytesSinceLastYield = 0;
        const YIELD_THRESHOLD = 50 * 1024 * 1024;

        (async function readAll() {
          try {
            while (true) {
              if (curSeq !== AppState.seq) { await reader.cancel(); return; }
              const {done, value} = await reader.read();
              if (done) {
                worker.postMessage({action: 'finalize'});
                if (isSmallFile && fullBuffer) {
                  const finalBuffer = (offset === fullBuffer.length) ? fullBuffer : fullBuffer.subarray(0, offset);
                  if (AppState.Base64Encode) onUpdate({'Base64-Enc': Core.encodeBase64(finalBuffer)});
                  if (AppState.Base85Encode) {
                    Base85Engine.encode(finalBuffer).then(res => {
                      if (curSeq === AppState.seq) {
                        if (res.type === 'error') onUpdate({'Base85-Enc': 'エラー'});
                        else onUpdate({'Base85-Enc': res.value});
                      }
                    });
                  }
                  
                  const tasks = [['SHA-384','SHA-384'], ['SHA-512','SHA-512']].map(async ([id, alg]) => {
                    try { const hex = await Core.digestHex(alg, finalBuffer); onUpdate({[id]: hex}); }
                    catch { onUpdate({[id]: '未対応/エラー'}); }
                  });
                  Promise.allSettled(tasks).then(checkDone);
                }
                break;
              }
              
              if (!isSmallFile) {
                worker.postMessage({action: 'update', bytes: value}, [value.buffer]);
              } else {
                worker.postMessage({action: 'update', bytes: value});
                if (fullBuffer) {
                  if (offset + value.length > fullBuffer.length) {
                    const newBuf = new Uint8Array(offset + value.length + Math.max(1024 * 1024, value.length));
                    newBuf.set(fullBuffer.subarray(0, offset), 0);
                    fullBuffer = newBuf;
                  }
                  fullBuffer.set(value, offset);
                  offset += value.length;
                }
              }

              bytesSinceLastYield += value.length;
              if (bytesSinceLastYield >= YIELD_THRESHOLD) {
                await new Promise(r => setTimeout(r, 0));
                bytesSinceLastYield = 0;
              }
            }
          } catch (e) {
            const errRes = {'MD5':'読込エラー', 'SHA-1':'読込エラー', 'SHA-256':'読込エラー', 'CRC32':'読込エラー'};
            if (isSmallFile) {
              errRes['SHA-384'] = '読込エラー'; errRes['SHA-512'] = '読込エラー';
              if (AppState.Base64Encode) errRes['Base64-Enc'] = '読込エラー';
              if (AppState.Base85Encode) errRes['Base85-Enc'] = '読込エラー';
            }
            onUpdate(errRes);
            checkDone();
            if (isSmallFile) checkDone();
            terminateWorker();
            ensureWorker();
          }
        })();
      } else {
        const reader = new FileReader();
        reader.onload = async e => {
          if (curSeq !== AppState.seq) return;
          const bytes = new Uint8Array(e.target.result);
          onUpdate({'MD5': Core.md5Hex(bytes), 'CRC32': Core.crc32Hex(bytes)});
          if (AppState.Base64Encode) onUpdate({'Base64-Enc': Core.encodeBase64(bytes)});
          if (AppState.Base85Encode) {
            Base85Engine.encode(bytes).then(res => {
              if (curSeq === AppState.seq) {
                if(res.type === 'error') onUpdate({'Base85-Enc': 'エラー'});
                else onUpdate({'Base85-Enc': res.value});
              }
            });
          }
          checkDone();

          if (isSmallFile) {
            const tasks = [['SHA-384','SHA-384'], ['SHA-512','SHA-512']].map(async ([id, alg]) => {
              try { const hex = await Core.digestHex(alg, bytes); onUpdate({[id]: hex}); }
              catch { onUpdate({[id]: '未対応/エラー'}); }
            });
            await Promise.allSettled(tasks);
            checkDone();
          }
        };
        reader.onerror = () => {
          const errRes = {};
          ['MD5','SHA-1','SHA-256','SHA-384','SHA-512','CRC32','Base64-Enc','Base64-Dec','Base85-Enc','Base85-Dec'].forEach(id => errRes[id] = '読込エラー');
          onUpdate(errRes);
          checkDone();
          if (isSmallFile) checkDone();
        };
        reader.readAsArrayBuffer(file);
      }
    });
  }

  async function hashText(bytesToHash, curSeq, onUpdate) {
    if (AppState.Base64Encode) onUpdate({'Base64-Enc': Core.encodeBase64(bytesToHash)});
    if (AppState.Base85Encode) {
      Base85Engine.encode(bytesToHash).then(res => {
        if (curSeq === AppState.seq) {
          if(res.type === 'error') onUpdate({'Base85-Enc': 'エラー'});
          else onUpdate({'Base85-Enc': res.value});
        }
      });
    }

    if (hasWorker && bytesToHash.length > WORKER_THRESHOLD) {
      return new Promise(async resolve => {
        let workerDone = false;
        let mainDone = false;
        const checkFinished = () => { if (workerDone && mainDone) resolve(); };

        worker.onerror = () => {
          onUpdate({'MD5':'ワーカーエラー', 'SHA-1':'ワーカーエラー', 'SHA-256':'ワーカーエラー', 'CRC32':'ワーカーエラー'});
          terminateWorker();
          ensureWorker();
          workerDone = true; checkFinished();
        };
        worker.onmessage = ev => {
          const {md5, sha1, sha256, crc} = ev.data;
          onUpdate({'MD5': md5, 'SHA-1': sha1, 'SHA-256': sha256, 'CRC32': crc});
          workerDone = true; checkFinished();
        };
        worker.postMessage({action: 'hashAll', bytes: bytesToHash});

        const tasks = [['SHA-384','SHA-384'], ['SHA-512','SHA-512']].map(async ([id, alg]) => {
          try { const hex = await Core.digestHex(alg, bytesToHash); onUpdate({[id]: hex}); }
          catch { onUpdate({[id]: '未対応/エラー'}); }
        });
        await Promise.allSettled(tasks);
        mainDone = true; checkFinished();
      });
    } else {
      onUpdate({'MD5': Core.md5Hex(bytesToHash), 'CRC32': Core.crc32Hex(bytesToHash)});
      const tasks = [['SHA-1','SHA-1'], ['SHA-256','SHA-256'], ['SHA-384','SHA-384'], ['SHA-512','SHA-512']].map(async ([id, alg]) => {
        try { const hex = await Core.digestHex(alg, bytesToHash); onUpdate({[id]: hex}); }
        catch { onUpdate({[id]: '未対応/エラー'}); }
      });
      await Promise.allSettled(tasks);
    }
  }

  function init() {
    ensureWorker();
  }

  return { init, hasWorker, WORKER_THRESHOLD, hashFile, hashText, terminateWorker };
})();

/* =========================================================
   UI LAYER — DOM Binding & Rendering
========================================================= */
const UI = (() => {
  const els = {};
  let scheduled = false;

  const TEST_VECTORS = {
    empty:{text:'',expect:{'MD5':'d41d8cd98f00b204e9800998ecf8427e','SHA-1':'da39a3ee5e6b4b0d3255bfef95601890afd80709','SHA-256':'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855','SHA-384':'38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b','SHA-512':'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e','CRC32':'00000000'}},
    abc:{text:'abc',expect:{'MD5':'900150983cd24fb0d6963f7d28e17f72','SHA-1':'a9993e364706816aba3e25717850c26c9cd0d89d','SHA-256':'ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad','SHA-384':'cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7','SHA-512':'ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f','CRC32':'352441c2'}}
  };

  function initDOM() {
    els.inputEl = document.getElementById('in');
    els.metaEl = document.getElementById('meta');
    els.themeBtn = document.getElementById('themeToggle');
    els.fsBtn = document.getElementById('fs');
    els.normBtn = document.getElementById('norm');
    els.hexBtn = document.getElementById('hexcase');
    els.toastEl = document.getElementById('toast');
    els.tvSel = document.getElementById('tv');
    els.applyBtn = document.getElementById('apply');
    els.verifyBtn = document.getElementById('verify');
    els.saveBtn = document.getElementById('save');
    els.groupingSel = document.getElementById('grouping');
    els.geoBtn = document.getElementById('geoToggle');
    els.zessBtn = document.getElementById('zessToggle');
    els.dropZone = document.getElementById('drop-zone');
    els.fileInput = document.getElementById('f-hidden');
    els.fileTrigger = document.getElementById('f-trigger');
    els.Base64EncToggleBtn = document.getElementById('Base64EncToggle');
    els.Base64DecToggleBtn = document.getElementById('Base64DecToggle');
    els.rowBase64Enc = document.getElementById('row-Base64-enc');
    els.rowBase64Dec = document.getElementById('row-Base64-dec');
    els.Base85EncToggleBtn = document.getElementById('Base85EncToggle');
    els.Base85DecToggleBtn = document.getElementById('Base85DecToggle');
    els.rowBase85Enc = document.getElementById('row-Base85-enc');
    els.rowBase85Dec = document.getElementById('row-Base85-dec');
    els.sysEl = document.getElementById('sys');
  }

  function showToast(msg) {
    els.toastEl.textContent = msg;
    els.toastEl.classList.add('show');
    setTimeout(() => els.toastEl.classList.remove('show'), 900);
  }

  function setSysOffset() {
    const h = els.sysEl.getBoundingClientRect().height || 0;
    const pad = Math.ceil(h + 24);
    document.documentElement.style.setProperty('--sys-offset', pad + 'px');
  }

  async function updateSysPanel() {
    const now = new Date(Date.now() + AppState.netTimeOffset);
    const dateStr = SysUtils.fmtJapaneseDate(now);
    const parts = [
      '製造: ソニーグループ株式会社 / インターナショナル・ビジネス・マシーンズ・コーポレーション（IBM） 2026',
      SysUtils.deviceInfo(),
      await SysUtils.networkDetail(),
      `位置: ${await SysUtils.detectGeo()}`,
      `日付: ${dateStr}`
    ];
    if (window.__ZESS_MODE__) {
      parts.unshift('【 ZESS (ZERO-EGRESS STATELESS SANDBOX) 稼働中 】');
    }
    els.sysEl.textContent = parts.join('\n');
    setSysOffset();
  }

  function renderResults(results) {
    for (const [id, value] of Object.entries(results)) {
      const el = document.getElementById(id);
      if (!el) continue;
      el.dataset.isBinary = '0';
      el._binBytes = null;
      el._fileInfo = null;

      if (typeof value === 'object' && value.type === 'binary') {
        const fi = Core.getFileInfo(value.bytes);
        el.dataset.raw = '';
        el.textContent = `[バイナリデータ: ${value.bytes.length} bytes / ${fi.ext.toUpperCase()}] クリックして保存`;
        el.dataset.empty = '0';
        el.dataset.isBinary = '1';
        el._binBytes = value.bytes;
        el._fileInfo = fi;
      } else if (!id.includes('Base') && /^[0-9a-fA-F]+$/i.test(value)) {
        const raw = String(value).toLowerCase();
        el.dataset.raw = raw;
        el.textContent = Core.formatForDisplay(raw, AppState.hexUpper, AppState.grouping);
        el.dataset.empty = '0';
      } else {
        el.dataset.raw = value || '';
        el.textContent = value || '入力待ち';
        el.dataset.empty = value ? '0' : '1';
      }
    }
  }

  function reformatAll() {
    const ids = ['MD5','SHA-1','SHA-256','SHA-384','SHA-512','CRC32', 'Base64-Enc', 'Base64-Dec', 'Base85-Enc', 'Base85-Dec'];
    for (const id of ids) {
      const el = document.getElementById(id);
      if (!el) continue;
      const raw = el.dataset.raw || '';
      if (!raw) continue;
      if (!id.includes('Base') && /^[0-9a-fA-F]+$/i.test(raw)) {
        el.textContent = Core.formatForDisplay(raw, AppState.hexUpper, AppState.grouping);
      }
    }
  }

  function updateMeta(count, isFile, statusText) {
    const normLabel = isFile ? 'なし' : AppState.normalization;
    const countLabel = isFile ? 'ファイル' : '文字数';
    const countUnit = isFile ? ' bytes' : '';
    const groupLabel = AppState.grouping ? `${AppState.grouping}字` : '連結';
    const hexLabel = AppState.hexUpper ? 'upper' : 'lower';
    els.metaEl.textContent = `${countLabel} ${count}${countUnit}｜正規化: ${normLabel}｜HEX: ${hexLabel}｜区切り: ${groupLabel}｜ステータス: ${statusText}`;
  }

  async function updateAll() {
    let bytesToHash;
    let isFile = false;
    let displayCount = 0;
    const raw = els.inputEl.value;

    if (AppState.currentFile && raw.startsWith('[File:')) {
      isFile = true;
      displayCount = AppState.currentFile.size;
    } else {
      AppState.currentFile = null;
      const cleaned = Core.sanitizeText(raw);
      if (cleaned !== raw) {
        const {selectionStart:a, selectionEnd:b} = els.inputEl;
        const delta = cleaned.length - raw.length;
        els.inputEl.value = cleaned;
        els.inputEl.selectionStart = Math.max(0, a + delta);
        els.inputEl.selectionEnd   = Math.max(0, b + delta);
      }
      const v = Core.normalizeText(cleaned, AppState.normalization);
      if (!v) {
        const emptyRes = {};
        ['MD5','SHA-1','SHA-256','SHA-384','SHA-512','CRC32', 'Base64-Enc', 'Base64-Dec', 'Base85-Enc', 'Base85-Dec'].forEach(id => emptyRes[id] = '');
        renderResults(emptyRes);
        updateMeta(0, false, '待機');
        return;
      }
      bytesToHash = Core.enc.encode(v);
      displayCount = Core.countGraphemes(v);
    }

    AppState.seq++;
    const curSeq = AppState.seq;
    updateMeta(displayCount, isFile, '計算中');

    if (AppState.Base64Decode && !isFile) {
      const decInfo = Core.decodeBase64Info(raw);
      if (decInfo.type === 'empty') renderResults({'Base64-Dec': ''});
      else if (decInfo.type === 'error') renderResults({'Base64-Dec': 'デコード不可'});
      else if (decInfo.type === 'binary') renderResults({'Base64-Dec': decInfo});
      else renderResults({'Base64-Dec': decInfo.value});
    }

    if (AppState.Base85Decode && !isFile) {
      if(!raw.trim()) {
        renderResults({'Base85-Dec': ''});
      } else {
        Base85Engine.decode(raw).then(res => {
          if (curSeq === AppState.seq) {
             if (res.type === 'error') renderResults({'Base85-Dec': 'デコード不可'});
             else if (res.type === 'binary') renderResults({'Base85-Dec': res});
             else renderResults({'Base85-Dec': res.value});
          }
        });
      }
    }

    if (isFile) {
      const isSmallFile = AppState.currentFile.size <= 50 * 1024 * 1024;
      const initRes = {'MD5': '計算中…', 'SHA-1': '計算中…', 'SHA-256': '計算中…', 'CRC32': '計算中…'};
      if (AppState.Base64Decode) initRes['Base64-Dec'] = 'ファイル非対応';
      if (AppState.Base85Decode) initRes['Base85-Dec'] = 'ファイル非対応';
      
      if (!isSmallFile) {
        initRes['SHA-384'] = 'サイズ超過 (MD5/SHA1/256/CRC32のみ)';
        initRes['SHA-512'] = 'サイズ超過 (MD5/SHA1/256/CRC32のみ)';
        if(AppState.Base64Encode) initRes['Base64-Enc'] = 'サイズ超過 (50MB以下のみ)';
        if(AppState.Base85Encode) initRes['Base85-Enc'] = 'サイズ超過 (50MB以下のみ)';
      } else {
        initRes['SHA-384'] = '計算中…'; initRes['SHA-512'] = '計算中…';
        if(AppState.Base64Encode) initRes['Base64-Enc'] = '計算中…';
        if(AppState.Base85Encode) initRes['Base85-Enc'] = '計算中…';
      }
      renderResults(initRes);

      await Engine.hashFile(AppState.currentFile, curSeq, res => {
        if (curSeq === AppState.seq) renderResults(res);
      });
      if (curSeq === AppState.seq) updateMeta(displayCount, isFile, '完了');
    } else {
      const initRes = {'MD5': '計算中…', 'SHA-1': '計算中…', 'SHA-256': '計算中…', 'CRC32': '計算中…', 'SHA-384': '計算中…', 'SHA-512': '計算中…'};
      if(AppState.Base64Encode) initRes['Base64-Enc'] = '計算中…';
      if(AppState.Base85Encode) initRes['Base85-Enc'] = '計算中…';
      if(Engine.hasWorker && bytesToHash.length > Engine.WORKER_THRESHOLD) renderResults(initRes);

      await Engine.hashText(bytesToHash, curSeq, res => {
        if (curSeq === AppState.seq) renderResults(res);
      });
      if (curSeq === AppState.seq) updateMeta(displayCount, isFile, '完了');
    }
  }

  function scheduleUpdate() {
    if (!scheduled) {
      scheduled = true;
      (window.requestIdleCallback || window.requestAnimationFrame)(() => {
        scheduled = false;
        updateAll();
      });
    }
  }

  function handleFiles(files) {
    if (!files.length) return;
    const f = files[0];
    AppState.currentFile = f;
    els.inputEl.value = `[File: ${f.name} (${f.size} bytes)]\n※このテキストを編集するとファイル状態が解除されます`;
    scheduleUpdate();
    showToast(`読込完了: ${f.name}`);
  }

  function attachEvents() {
    const THEMES = [
      { id: 'default', label: 'DEFAULT' },
      { id: 'cmd', label: 'CMD' },
      { id: 'ps', label: 'PowerShell' }
    ];

    function applyTheme() {
      document.body.setAttribute('data-theme', AppState.theme);
      const t = THEMES.find(x => x.id === AppState.theme) || THEMES[0];
      els.themeBtn.textContent = `テーマ: ${t.label}`;
    }

    AppState.theme = localStorage.getItem('sonyHash.theme') || 'default';
    applyTheme();

    els.themeBtn.addEventListener('click', () => {
      const idx = THEMES.findIndex(x => x.id === AppState.theme);
      AppState.theme = THEMES[(idx + 1) % THEMES.length].id;
      localStorage.setItem('sonyHash.theme', AppState.theme);
      applyTheme();
    });

    els.fileTrigger.addEventListener('click', () => els.fileInput.click());
    els.fileInput.addEventListener('change', e => handleFiles(e.target.files));
    els.dropZone.addEventListener('dragover', e => { e.preventDefault(); els.dropZone.classList.add('dragover'); });
    els.dropZone.addEventListener('dragleave', () => { els.dropZone.classList.remove('dragover'); });
    els.dropZone.addEventListener('drop', e => {
      e.preventDefault();
      els.dropZone.classList.remove('dragover');
      handleFiles(e.dataTransfer.files);
    });

    els.inputEl.addEventListener('paste', e => {
      if (AppState.currentFile) AppState.currentFile = null;
      e.preventDefault();
      const t = e.clipboardData.getData('text');
      const clean = Core.sanitizeText(t);
      const {selectionStart:a, selectionEnd:b, value:v} = els.inputEl;
      els.inputEl.value = v.slice(0,a) + clean + v.slice(b);
      els.inputEl.selectionStart = els.inputEl.selectionEnd = a + clean.length;
      scheduleUpdate();
    });

    els.inputEl.addEventListener('input', () => {
      if (AppState.currentFile) AppState.currentFile = null;
      scheduleUpdate();
    });
    els.inputEl.addEventListener('compositionend', scheduleUpdate);

    document.querySelectorAll('.value').forEach(el => {
      el.addEventListener('click', async () => {
        if (el.dataset.isBinary === '1' && el._binBytes) {
          const fi = el._fileInfo || {ext: 'bin', mime: 'application/octet-stream'};
          const blob = new Blob([el._binBytes], {type: fi.mime});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          const ts = new Date();
          const pad = n => String(n).padStart(2,'0');
          a.href = url;
          a.download = `decoded_${ts.getFullYear()}${pad(ts.getMonth()+1)}${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}.${fi.ext}`;
          document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
          showToast(`保存開始: ${a.download}`);
          return;
        }
        const raw = el.dataset.raw || el.textContent.trim();
        if (!raw || el.dataset.empty === '1') return;
        try { await navigator.clipboard.writeText(raw); showToast(`コピー: ${el.dataset.alg}`); } catch(_) {}
      });
      el.addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); el.click(); }
      });
    });

    els.normBtn.addEventListener('click', () => {
      AppState.normalization = AppState.normalization === 'NFC' ? 'NFKC' : AppState.normalization === 'NFKC' ? 'none' : 'NFC';
      els.normBtn.textContent = `正規化: ${AppState.normalization}`;
      scheduleUpdate();
    });

    els.hexBtn.addEventListener('click', () => {
      AppState.hexUpper = !AppState.hexUpper;
      els.hexBtn.textContent = `HEX: ${AppState.hexUpper ? 'upper' : 'lower'}`;
      reformatAll();
      els.metaEl.textContent = els.metaEl.textContent.replace(/HEX:\s*(upper|lower)/, `HEX: ${AppState.hexUpper ? 'upper' : 'lower'}`);
    });

    els.Base64EncToggleBtn.addEventListener('click', () => {
      AppState.Base64Encode = !AppState.Base64Encode;
      els.Base64EncToggleBtn.textContent = `Base64 Enc: ${AppState.Base64Encode ? 'オン' : 'オフ'}`;
      els.rowBase64Enc.style.display = AppState.Base64Encode ? 'flex' : 'none';
      if (AppState.Base64Encode) scheduleUpdate();
      else renderResults({'Base64-Enc': ''});
    });

    els.Base64DecToggleBtn.addEventListener('click', () => {
      AppState.Base64Decode = !AppState.Base64Decode;
      els.Base64DecToggleBtn.textContent = `Base64 Dec: ${AppState.Base64Decode ? 'オン' : 'オフ'}`;
      els.rowBase64Dec.style.display = AppState.Base64Decode ? 'flex' : 'none';
      if (AppState.Base64Decode) scheduleUpdate();
      else renderResults({'Base64-Dec': ''});
    });

    els.Base85EncToggleBtn.addEventListener('click', () => {
      AppState.Base85Encode = !AppState.Base85Encode;
      els.Base85EncToggleBtn.textContent = `Base85 Enc: ${AppState.Base85Encode ? 'オン' : 'オフ'}`;
      els.rowBase85Enc.style.display = AppState.Base85Encode ? 'flex' : 'none';
      if (AppState.Base85Encode) scheduleUpdate();
      else renderResults({'Base85-Enc': ''});
    });

    els.Base85DecToggleBtn.addEventListener('click', () => {
      AppState.Base85Decode = !AppState.Base85Decode;
      els.Base85DecToggleBtn.textContent = `Base85 Dec: ${AppState.Base85Decode ? 'オン' : 'オフ'}`;
      els.rowBase85Dec.style.display = AppState.Base85Decode ? 'flex' : 'none';
      if (AppState.Base85Decode) scheduleUpdate();
      else renderResults({'Base85-Dec': ''});
    });

    els.groupingSel.addEventListener('change', () => {
      AppState.grouping = parseInt(els.groupingSel.value, 10) || 0;
      reformatAll();
      els.metaEl.textContent = els.metaEl.textContent.replace(/区切り:\s*(連結|\d+字)/, `区切り: ${AppState.grouping ? AppState.grouping + '字' : '連結'}`);
    });

    els.applyBtn.addEventListener('click', () => {
      els.inputEl.value = TEST_VECTORS[els.tvSel.value].text;
      scheduleUpdate();
    });

    els.verifyBtn.addEventListener('click', async () => {
      const v = Core.normalizeText(Core.sanitizeText(TEST_VECTORS[els.tvSel.value].text), AppState.normalization);
      const bytes = Core.enc.encode(v);
      const results = {'MD5': Core.md5Hex(bytes), 'CRC32': Core.crc32Hex(bytes)};
      results['SHA-1']   = await Core.safeAsync(() => Core.digestHex('SHA-1', bytes), '');
      results['SHA-256'] = await Core.safeAsync(() => Core.digestHex('SHA-256', bytes), '');
      results['SHA-384'] = await Core.safeAsync(() => Core.digestHex('SHA-384', bytes), '');
      results['SHA-512'] = await Core.safeAsync(() => Core.digestHex('SHA-512', bytes), '');
      let ok = 0;
      for (const k of ['MD5','SHA-1','SHA-256','SHA-384','SHA-512','CRC32']) {
        if (String(results[k]||'').toLowerCase() === TEST_VECTORS[els.tvSel.value].expect[k]) ok++;
      }
      showToast(ok===6 ? `検証OK ${ok}/6` : `検証NG ${ok}/6`);
    });

    els.saveBtn.addEventListener('click', () => {
      const ts = new Date();
      const pad = n => String(n).padStart(2,'0');
      const fn = `sony-hash-${ts.getFullYear()}${pad(ts.getMonth()+1)}${pad(ts.getDate())}-${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}.txt`;
      const lines = [];
      lines.push('SONY HASH export');
      lines.push('製造: ソニーグループ株式会社 / インターナショナル・ビジネス・マシーンズ・コーポレーション（IBM） 2026');
      lines.push(`正規化: ${AppState.currentFile ? 'なし' : AppState.normalization}｜HEX: ${AppState.hexUpper ? 'upper' : 'lower'}｜区切り: ${AppState.grouping ? AppState.grouping + '字' : '連結'}`);
      lines.push('');
      lines.push('[INPUT]');
      lines.push(els.inputEl.value);
      lines.push('');
      lines.push('[DIGEST]');
      for (const id of ['MD5','SHA-1','SHA-256','SHA-384','SHA-512','CRC32', 'Base64-Enc', 'Base64-Dec', 'Base85-Enc', 'Base85-Dec']) {
        if (!AppState.Base64Encode && id === 'Base64-Enc') continue;
        if (!AppState.Base64Decode && id === 'Base64-Dec') continue;
        if (!AppState.Base85Encode && id === 'Base85-Enc') continue;
        if (!AppState.Base85Decode && id === 'Base85-Dec') continue;
        const el = document.getElementById(id);
        const raw = el.dataset.raw || el.textContent.trim();
        lines.push(`${id}: ${raw}`);
      }
      const blob = new Blob([lines.join('\n')], {type:'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = fn; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    els.fsBtn.addEventListener('click', async () => {
      const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
      try {
        if (!isFs) await (document.documentElement.requestFullscreen?.() || document.documentElement.webkitRequestFullscreen?.());
        else await (document.exitFullscreen?.() || document.webkitExitFullscreen?.());
      } catch(_) {}
    });

    document.addEventListener('fullscreenchange', () => {
      const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
      els.fsBtn.textContent = isFs ? '通常表示' : '全画面';
      setSysOffset();
    });

    if (window.__ZESS_MODE__) {
      els.zessBtn.textContent = 'ZESS: 稼働中 (解除はリロード)';
      els.zessBtn.classList.add('warn');
      els.geoBtn.style.display = 'none';
      els.zessBtn.addEventListener('click', () => {
        const url = new URL(window.location.href);
        url.searchParams.delete('airgap');
        url.hash = '';
        window.location.href = url.toString();
      });
    } else {
      els.zessBtn.addEventListener('click', () => {
        const url = new URL(window.location.href);
        url.searchParams.set('airgap', '1');
        window.location.href = url.toString();
      });
    }

    if (!window.__ZESS_MODE__) {
      AppState.geoEnabled = (localStorage.getItem('sonyHash.geo') || 'off') === 'on';
      els.geoBtn.textContent = `位置: ${AppState.geoEnabled ? 'オン' : 'オフ'}`;
      els.geoBtn.addEventListener('click', async () => {
        AppState.geoEnabled = !AppState.geoEnabled;
        localStorage.setItem('sonyHash.geo', AppState.geoEnabled ? 'on' : 'off');
        AppState.geoLabel = AppState.geoEnabled ? '照会中…' : '照会オフ';
        AppState.geoTs = 0;
        els.geoBtn.textContent = `位置: ${AppState.geoEnabled ? 'オン' : 'オフ'}`;
        updateSysPanel();
      });

      if (navigator.getBattery) {
        navigator.getBattery().then(b => {
          const upd = () => { AppState.battStr = `${Math.round(b.level*100)}%${b.charging ? ' （充電状態）' : ''}`; updateSysPanel(); };
          upd(); b.addEventListener('levelchange', upd); b.addEventListener('chargingchange', upd);
        }).catch(() => {});
      }

      window.addEventListener('online', async () => {
        await SysUtils.syncNetworkTime();
        SysUtils.resetIpCache();
        AppState.geoTs = 0;
        updateSysPanel();
      });

      window.addEventListener('offline', () => {
        AppState.netTimeOffset = 0;
        AppState.geoLabel = 'オフライン利用';
        updateSysPanel();
      });
    }

    window.addEventListener('resize', () => { setSysOffset(); });
    window.addEventListener('load', () => { els.inputEl.focus(); setSysOffset(); });
    window.addEventListener('beforeunload', () => { Engine.terminateWorker(); Base85Engine.terminate(); });
  }

  function init() {
    initDOM();
    attachEvents();
  }

  return { init, updateSysPanel };
})();

/* =========================================================
   APP ENTRY — Orchestration
========================================================= */
(async function initApp() {
  Security.init();
  Engine.init();
  UI.init();
  
  if (!window.__ZESS_MODE__) {
    await SysUtils.syncNetworkTime();
  }
  
  await UI.updateSysPanel();
  setInterval(() => { UI.updateSysPanel(); }, 1000);
})();

</script>
</body>
</html>
